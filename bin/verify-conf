#!/usr/bin/env python3
"""Quick sanity checks for pulse.conf."""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path

TRUE_VALUES = {"1", "true", "yes", "on", "enable", "enabled"}


@dataclass(frozen=True)
class CheckResult:
    level: str
    message: str


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Verify required PulseOS config values.")
    parser.add_argument(
        "--path",
        "-p",
        help="Path to pulse.conf (defaults to /opt/pulse-os/pulse.conf or ./pulse.conf)",
    )
    return parser.parse_args()


def resolve_config_path(user_supplied: str | None) -> Path:
    if user_supplied:
        candidate = Path(user_supplied).expanduser()
        if not candidate.exists():
            raise FileNotFoundError(f"Config file not found: {candidate}")
        return candidate

    candidates = [
        Path("/opt/pulse-os/pulse.conf"),
        Path(__file__).resolve().parent.parent / "pulse.conf",
    ]
    for candidate in candidates:
        if candidate.exists():
            return candidate
    raise FileNotFoundError(
        "pulse.conf not found. Pass --path or copy pulse.conf into the repo root."
    )


def load_config(path: Path) -> dict[str, str]:
    values: dict[str, str] = {}
    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith(("if ", "fi", "then", "elif", "else")):
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        key = key.strip()
        if not key:
            continue
        value = value.strip()
        if len(value) >= 2 and value[0] == value[-1] and value[0] in {'"', "'"}:
            value = value[1:-1]
        values[key] = value
    return values


def as_bool(value: str | None, default: bool = False) -> bool:
    if value is None:
        return default
    return value.strip().lower() in TRUE_VALUES


def split_csv(value: str | None) -> list[str]:
    if not value:
        return []
    return [chunk.strip() for chunk in value.split(",") if chunk.strip()]


def run_checks(config: dict[str, str], config_path: Path) -> list[CheckResult]:
    results: list[CheckResult] = [
        CheckResult("info", f"Loaded config: {config_path}"),
    ]

    voice_enabled = as_bool(config.get("PULSE_VOICE_ASSISTANT"), False)
    provider = (config.get("PULSE_ASSISTANT_PROVIDER") or "openai").lower()
    mqtt_host = (config.get("MQTT_HOST") or "").strip()

    if not mqtt_host:
        level = "error" if voice_enabled else "warning"
        results.append(
            CheckResult(level, "MQTT_HOST is empty; assistant telemetry and overlay require it.")
        )

    if not voice_enabled:
        results.append(
            CheckResult("info", "PULSE_VOICE_ASSISTANT is disabled; skipping voice assistant checks.")
        )
        return results

    def require(var: str, description: str) -> None:
        if not (config.get(var) or "").strip():
            results.append(CheckResult("error", description))

    require(
        "WYOMING_OPENWAKEWORD_HOST",
        "Set WYOMING_OPENWAKEWORD_HOST to the host/IP running wyoming-openwakeword.",
    )
    require(
        "WYOMING_WHISPER_HOST",
        "Set WYOMING_WHISPER_HOST to the host/IP running wyoming-whisper.",
    )
    require(
        "WYOMING_PIPER_HOST",
        "Set WYOMING_PIPER_HOST to the host/IP running wyoming-piper.",
    )

    wake_words = split_csv(config.get("PULSE_ASSISTANT_WAKE_WORDS"))
    if not wake_words:
        results.append(
            CheckResult(
                "warning",
                "No wake words configured; the assistant defaults to 'okay_pulse'.",
            )
        )
    else:
        results.append(
            CheckResult("info", f"Wake words configured: {', '.join(wake_words)}"),
        )

    if provider != "openai":
        results.append(
            CheckResult(
                "warning",
                f"PULSE_ASSISTANT_PROVIDER={provider!r} is not implemented; only 'openai' works today.",
            )
        )
    else:
        api_key = (config.get("OPENAI_API_KEY") or "").strip()
        if not api_key:
            results.append(
                CheckResult(
                    "error",
                    "OPENAI_API_KEY is empty but provider is 'openai'. Create an API key and add it to pulse.conf.",
                )
            )
        elif not api_key.startswith("sk-"):
            results.append(
                CheckResult(
                    "warning",
                    "OPENAI_API_KEY does not look like an sk- token; double-check for typos.",
                )
            )

    actions_file = (config.get("PULSE_ASSISTANT_ACTIONS_FILE") or "").strip()
    if actions_file:
        candidate = Path(actions_file)
        if not candidate.is_absolute():
            candidate = (config_path.parent / candidate).resolve()
        if candidate.exists():
            results.append(CheckResult("info", f"Found assistant actions file: {candidate}"))
        else:
            results.append(
                CheckResult(
                    "warning",
                    f"PULSE_ASSISTANT_ACTIONS_FILE points to {candidate}, but that file does not exist.",
                )
            )
    elif not (config.get("PULSE_ASSISTANT_ACTIONS") or "").strip():
        results.append(
            CheckResult(
                "info",
                "No assistant actions configured; the LLM will not be able to trigger automations.",
            )
        )

    return results


def print_report(results: list[CheckResult]) -> int:
    severity = {"error": 2, "warning": 1, "info": 0}
    errors = sum(1 for result in results if result.level == "error")
    warnings = sum(1 for result in results if result.level == "warning")

    for result in results:
        label = result.level.upper().ljust(7)
        print(f"[{label}] {result.message}")

    if errors:
        print(f"\nFound {errors} error(s) and {warnings} warning(s). Fix the errors above.")
        return 1
    if warnings:
        print(f"\nAll critical checks passed, but there are {warnings} warning(s).")
    else:
        print("\nAll checks passed.")
    return 0


def main() -> int:
    args = parse_args()
    try:
        config_path = resolve_config_path(args.path)
    except FileNotFoundError as exc:
        print(f"Error: {exc}")
        return 1
    config = load_config(config_path)
    results = run_checks(config, config_path)
    return print_report(results)


if __name__ == "__main__":
    raise SystemExit(main())

